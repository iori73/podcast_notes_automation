## **基本情報**

- Spotify URL：[エピソードリンク](https://open.spotify.com/episode/1aXrVzvCbkabwBAakQA75u?si=uiS4ETgQRsesmHJX4On9lA)
- 公開日：2025年02月08日
- 長さ：23:38

## **要約**

ロンドンテクトクの桂馬勝馬がDatabase Internals Book Clubの第2回を振り返り、B3（B-木）について詳しく説明しています。エピソードでは、データベースにおけるB3の重要性や動作原理に焦点が当てられ、効率的なデータ管理のためにB3が果たす役割が強調されています。また、参加メンバーが共有したYouTube動画やウェブアプリなどの外部リソースを活用することで、B3の理解を深める方法が提案されています。また、ハードディスクやSSDの動作原理についても触れられ、DBMSやB3における最適化の重要性が明確に説かれています。このエピソードは、データベースの基本的概念や最適化に興味を持つ方にとって非常に興味深い内容となっています。外部リソースを駆使してB3の理解を深め、データベースの内部動作に迫ることができるでしょう。

## **目次**

00:20 エピソード紹介とテーマの提示
01:03 B3データ構造の解説
03:44 ブッククラブの比較
05:12 B3の議論
05:35 データベースマネジメントシステムの重要キーワード
08:07 データレイアウトとディスクシーク
09:16 YouTubeでのB3解説講義
10:17 ウェブアプリを活用したB3の実践表現
13:24 B3の最適化に関する理解
13:52 B3のアッシュとバリアンス
14:54 B3とBプラス3の違い
15:56 LSMツリーとSSテーブルとの関係
19:40 スケーリングとパフォーマンス最適化
20:06 LocksDBとMyLocksの実装

## **文字起こし**

♪ リスナーのみなさん こんにちは ロンドンテクトクへようこそ ロンドンからお届けしています 桂馬勝馬です 本日はDatabase Internals Book Club 第2回の振り返りについて ソロ収録で収録していこうと思います 今回はチャプター2のB3ベーシックスを取り上げていきます データベースの話をしていると 必ずと言っていいほどB3は出てくるんじゃないかなと思ってます 皆さんもインデックスの話をしたり データベースのパフォーマンスをチューニングしたり オンラインの記事を見たときにB3という話を耳にしたことが 耳にしたり聞いたことがある方は多いんじゃないでしょうか でもどうしてB3っていうのがDBMSでそんなに使われるのか 例えば単純なバイナリーサイススイッチでダメなのかという疑問を 持った方はいるんじゃないでしょうか そもそもこの今回データベースインターナルズで使っている データベースマネジメントシステムDBMSというのは 大量のデータを安価に保存しながら 高速に検索であったり更新できるような仕組みが求められます なのでディスクベースのDBMSの場合ですけれども データはディスクに格納されるわけですけれども ディスクってメモリほど早くないんですよね 特にランダムアクセスはめちゃくちゃ遅い だからこそデータの局所性データローカリティというんですけれども を高めつつディスクアクセスの回数を減らすような データ構造が必要になるわけですね この要件を満たすというのがB3です 正確にはBプラス3なんですけれども このハイファンアウトでローハイトな構造を実現していることによって ディスクのシーク回数を抑えながらディスクアイを抑えながら 検索とか更新を効率的に行えるようになっています なのでこのチャプター2を読むと どうして特にディスクベースDBMSの世界において B3がこんなに出てくるのかというのが分かります そのためにはB3の基本操作 あと基本構造についてもこの章で掘り下げられています 例えば検索のときにセパレーターキーズを使って 効率よく目的のデータにどうやって辿り着くのかであったり キーが想定されていることによって レンジクエリによって必要なデータを 丸と取ってくれるような仕組みであったりとか あとは新しいデータを追加したり削除したりするときに B3というのはバランスの状態である必要があるんですけども そのバランス状態を維持するために ノードをスプリットしたりマージしたり 分割したり統合したりというのも必要になってきます こうしたB3の基本操作というのを メンタルモデルとして理解するのが 今回の章のゴールかなと思っています ということで今日はですね 本章のチャプター2B3ベーシックスの簡単な内容を振り返りつつ どういった議論が盛り上がったかというのを お伝えしていこうかなと思います 今回はイミヤとノースアメリカのメンバーで参加しました APACチームは非同期で参加するという形になりまして 今回はAPACチームが一番参加者が多いので イミヤとノースアメリカっていうのが 一番人数が少ない時間帯の会になるんですね 初回はAPACとイミヤでブッククラブを行ったんですけども その時はすごい人数が多くて熱気に溢れてるというか 初回ということもあったんですけども これから難しいもの読んでいくぞみたいな すごいいいアップワードな雰囲気があったかなと思います 一方今回はですね すごい少人数で全員参加できて7人かな 今回お二人参加できなかったので 1,2,3,4,5、5人で参加したんですけども 少人数のブッククラブもいいですね 和やかなというか 一人一人が喋る時間というのもすごいたっぷり与えられるし 流れていく雰囲気も 5時、6時ぐらいの大学の夕暮れ時の校舎で みんなでゼミみたいな感じで論文読み合ってるみたいな 難しけどのどかな雰囲気みたいな感じが流れていて そんな雰囲気の 全然会によって雰囲気が違うんだなというのが 個人的な発見で面白かったですね なので今回は結構B3について深く議論できたかなと思います 今回の第2章の個人的に考えている 最低限を抑えたいポイントというのが イントロでもお伝えしたんですけれども どうしてB3が好まれるのかというのを理解できたら この章を読んだゴール達成できたかなと思います そもそもやっぱりデータベースマネジメントシステムというのは 大量のデータを安価に保存する必要があるので ハードディスクとかSSDにおいて いかにデータを格納しつつ早い読み書きを実現できるか というところでまず2つ重要なキーワードがありましたね 1つがハイファンアウトということで これはデータローカリティが優れている書き込みはランダムに書き込まれていくので、関連性に応じて近くに保存していくということが必要です。 読み書きの回数を抑えるためにディスク回数の回数も抑えていきたいので、 木構造にしたときの木の高さが、例で紹介しますけど、 試行実験として、この本でも紹介されているんですけど、 データをBSTで保存するか、あとはB3で保存するかを比べたときに、 バイナリーサーチツリーというのは、1つのノードに対して2つのチルドレンノード、小ノードが付くんですね。 なので例えば、大量のデータを保存するとなると、木の高さというのがすごい高くなってしまいます。 DBMSは木のノードごとにデータブロックとして、ページとして保存するので、 木の構造が高くて、木を何回も辿らなきゃいけないということ、それだけディスクから読み込まなきゃいけないということなんですね。 DBMSの操作において一番遅いのはディスクからページを持ってくるところなので、 基本的な発想としてはディスクの回数を抑えたい。 そのためには、1つのノードに対してバイナリーサーチツリーのように、2つだけのチルドレンノードが付くのではなくて、 複数のチルドレンノードが付くようにすると、木の高さというのが圧縮されるんですね。 これはローハイトになります。 そのローハイトを実現することによってディスクシークの回数を抑えられるようなデータ構造になるという形になっています。 なのでこのハイファンアウトというのはチルドレンノードの数が多くて、ファンアウトが広がっていくということですね。 このハイファンアウトを実現するということはローハイトを実現するということと表裏一体なんですけれども、 これによってディスクフレンドリーというかディスクローカリティが優れていて、 ディスクシークの回数を抑えられるようなデータレイアウトが実現できるというところが 〇〇チャプターを通して書かれています。 B3の基本操作というのも主に2つ理解できるといいかなと思っていて、 まず1つがルックアップですね。 サーチ、ゲット、要するに情報を読み取りに行くということですね。 自分の頭の中でB3上にデータを保存してみて、 このキーがクエリが来たときにこのキー構造をどういうふうに辿っていくと目的のノードに辿り着くことができるのかというのを なんとなくビジュアライズしながら理解できるといいんじゃないかなと思います。 この本を読むという手法だけですとですね、 ここら辺の動的な動きというのはすごいビジュアライズしづらいので、 これは参加者の方が共有してくれたんですけれども、 CMU、カネギメロユニバーシティの有名なデータベース関連の講義のYouTube動画が上がっているんですけれども、 その中の1つにB3について詳細に話された講義の回がありまして、 そこにノードスプリットとかノード回しとかルックアップするときの ビジュアライズされた簡易的なアニメーション、スライドで表現されているアニメーションがあって、 それを見るとビジュアライズ、視覚的に理解することができるので、 ここら辺は例えばYouTubeとかショーノートにもリンク貼ろうと思うんですけれども、 そういったB3のルックアップするときには機構像の中をこういうふうにたどっていくよねやったり、 ノードスプリットノード回しをするときにはこういうふうに 最適的にノードをスプリットしたり投稿したりするんだなということが視覚的に理解するといいんじゃないかなと思います。 あともう1つは、これも他の参加者の方が共有してくれたんですけど、 ウェブアプリでおそらく全てJavaScriptで表現されているのかな、 自分でどのデータを入れるかというのをテキストフィールドでインプットして、 インプットし続けるとウェブブラウザ上に実際の機構像、B3を表現できるというウェブアプリもあるみたいで、 こういうのも自分で好きなデータ、例えば1とか2とか3とか順番にインテジェーターとかを入れてみて、 こういうふうに機構像が動くんだね、 実際にデータを消したときにここがこういうふうに分かれているんだねというのをテストしながら、 より深く理解できるようになるんじゃないかなと思います。 こちらも教えてもらったリンクはshow.netに貼りたいなと思っています。 基本的にパート1の前半はB3を深く理解するというところにページ数が割かれていますね。 チャプター3とかチャプター4もこのチャプター2の基本的なB3の操作を理解した上で話が進んでいくので、 ここはぜひ時間をかけてYouTubeとかウェブアプリみたいな外部のリソースも、 自分の学習スタイルに合わせて適宜応用しつつ理解するといいんじゃないかなと思います。 結構議論も盛り上がりまして、いくつかピックアップしようかな。 まずチャプター2の前半でディスクについての説明がありました。 そもそもハードディスク、ドライブとかSSDとかについてブロックレベルでどう動くのかとか、ディスクシークって何?みたいなのがありまして、例えばこれもそのハードディスクドライブを何だろう、もしかしたらここ数年でコンピューターの世界に入られた方はハードディスクを使ったことがない方もいるかもしれません。 僕は一応ハードディスクドライブが主流だった時期にコンピューターの世界に入っているので最初のコンピューターはハードディスクとかでしたけれども、 最近のMacとか買うと基本SSDなので、ハードディスクが実はディスク型でディスクシークというのが針とディスクがこういうふうに動いて、 というのをもしかしたら知らない方もいると思うので、これはぜひイメージとかYouTubeとかでハードディスクというものはどういうふうに動くのかというのを初見の方はぜひ見てもらいたいなと思います。 そうするとどうしてDBMSがこんなにディスクシークの回数を減らさなきゃいけないのかというのが納得できると思います。 ディスクシークするのを特にハードディスクドライブで表現しようとするのはめちゃくちゃ時間がかかる操作なんですね。 なので基本的にここがボトルネックになってしまうので、いかにハードディスク上でディスクシークを抑えるかというのをまず負に落とすというところがこのチャプターを読む前に必要な前提知識というかマインドセットかなと思います。 あまり負に落ちてないとどうしてこんなにデータベースエンジニアは頑張ってB3を最適化しようとするのかという、そもそも論のところに入れない気持ちが理解できないと思うので、 ぜひハードディスクドライブでできればSSDのところも簡単にでいいので抑えておくと、この本の著者の気持ちがわかると思います。 そして、その後でB3というのもですね、最初は確か1970年かなオリジナルのB3というのが発表されましたが、その後でいろんなアッシュがというかバリアンスが発表されてきました。 ブリンクツリーであったりBプラスツリーであったり、本当にそのベースのB3を元に例えば書き込みのパフォーマンスを上げるためのライトオプティマイズバランスB3であったりとか、 あと同じレベルのノード感の移動をシブリングポインターで移動しやすいようにちょっと変えたB3、いろんなアッシュが出てきましたが、 ここで抑えたいポイントというのは、だいたいマイシークレットかポスグレみたいなDBMSの世界でB3と呼ばれたときには、 競技の意味でのB3を話しているのか、抗議の意味でのB3を話しているのか、どっちの話をしているのかというのをまず理解する必要があります。 競技のB3というのが1970年の論文で発表されたものですけれども、 オンライン上とかドキュメンテーションでB3というときにこっちを指していることはあまりないんじゃないかなと思います。 アカデミズムの世界とか特定の論文を指している場合でない限り。 基本的にはB3というのはよく使われるのがBプラス3なんですけれども、 B3との違いでいうと、データブロックとチルドレンノード、古ノードへのポインターをどこに格納するかどうかの違いですね、平たく言うと。 もともとのB3というのが中間ノード、だから気構造で考えたときの一番上のルートノードと一番下のリーフノード、その間にある中間ノードがあったときに、 中間ノードにデータを格納する前提で考案されたのがもともとのB3なんですけれども、 その後でデータをリーフノードにだけ格納した方がパフォーマンスが上がるよねという風に提案されたのが1973年だったかな、Bプラス3です。 なので基本的にはDBMSの世界ではBプラス3について話されているんだなということがなんとなく理解できるといいんじゃないかなと思っています。 ハードディスクSSDの気持ちを踏まえた上で、なぜB3をこんなに最適化しているのかというのがまず分かった上で、 B3にもいろんなアシュがあってBプラス3とかについて話されているんだな、 そしてB3の基本的な操作というのを理解すると、この章を読んだ目標は達成できたんじゃないかなと思います。 ここの基本を抑えた上で、あとは自分が使っているデータベースマネジメントシステムでは、 どんなインデックス、どのデータ構造、そのB3のアシュをサポートしているんだなというのを調べてみたり、 あとはハードディスクとかSSDの動きについてもうちょっと詳しく調べてみたりであったり、 ここから先は個人の好みとか興味・関心によってもう一歩深掘る方向性はいろいろありました。 違っていたかなと思います。 個人的にはこの章を読んでB3の基本的な、昔読んだデータ構造の本の中身をリフレッシュするみたいな感じで読みましたね。 ここはもう本当にイントロでもお伝えしたんですけども、ここは大事な章なので、 例えばこの本後半になっていくと、LSMツリー、ログストラクチャマジツリーとか、 結構最近の実アプリケーション、メーターが作っているOxDBとかでも使われているような、LMシリーズデータベースでも使えるような別のデータ構造というのが出てくるんですね。 LSMツリーとかそこで使えているSSテーブルみたいなのを理解するためには、 そもそもその前、データベースの長い歴史の中で最初は最初というか、 LSMツリーとかSSテーブルみたいなものが出てくる前はBツリーという世界で頑張っていたということを理解すると、 他の発展的なデータ構造とかその次の流れとかに行けると思います。 あと最後に一つ、面白いというかこれの章を読んでて、今回僕がちょっと詳しく調べてみたものがありまして、 例えばMySQLってありますよね。RDBMSのディスクベースの基本的にはディスクベースのDBMSというのがあります。 このMySQLを使っている企業も世の中にはたくさんありまして、いろんなあの手この手で最適化しようとしています。 デフォルトで使うとおそらくストレージエンジンの実装としてはinnoDBと言われるものが使われて、 ここではBツリーインデックスベースの実装を使うことになると思うんですけれども、 ここのBツリーを基本的に理解すると、例えばある程度のスケールまではライトパフォーマンスが上がるんだけれども、 一定以上のスケール、例えばFacebookレベルとか大企業というかグローバルで使われるようなレベル、 YouTubeとかもかな、なると必ずどこかでボトルネックが出てくるので、 そこをどういうふうに改善し、他の企業を改善しているんだろうというのはいろんな、 このホリジョンタルスケールを達成することでリードを増やしたりだとかいろんな方法があるんですけど、 その一つの面白い、これは結構もう2006、7年ぐらいに公開されているので知っている方もいるかと思うんですけれども、 FacebookでMyLocksという実装がありまして、これはどういうことかというと、 まずどこから話そう、デフォルトで使われるInnoDBのストレージエンジンを、 LocksDBという全然別のキーバリューストアでまるっと切り替えちゃったというプロジェクトなんですね。 LocksDBというのはシープラプラで書かれた、これもFacebookから出ているオープンソースのリストで、 ロゴ、プーマかな、ヒョウかな、ちょっと確認しなかったんですけど、 要するに速く走っている動物のロゴのLocksDBなので見たことがある方もいるかもしれません。 これがLSMと呼ばれるログストラクチャーマッジ3、SSテーブル実装ベースのキーバリューストアなんですね。 Liteのパフォーマンスをすごい高めたかったという事例があったので、 今までのInnoDBベースのB3のインデックスで頑張るのではなく、そこのインデックスレベルの実装もまるっと全く別のものに置き換えることによって、 特定のユースケースに合うような、全然別のMyLocksというものを発表しましたよというのが、これ公開されているんですけども、 そういった事例もあったりしますと。 なので、そういったMyLocksも個人的に面白いなと思ったんですけど、 そこらへん、そもそもなぜFacebookレベルのスケールでアプリケーションを合化さなければいけない人たちが、 デフォルトのInnoDBではなぜ対応できなかったかというのも、 裏側でB3というものを使っていて、それがどういう動きでどういう構造になっていて、 どういう場面でパフォーマンスボトルネックにぶち当たるのかというのを理解しておくと、 だからMyLocksDBというかLocksDBのようなASM3ベースの書き換えが必要だったんだなというのがピンとくると思います。 なので、データベースのオンライン記事とか他社の取り組みとかを理解するときにも、 データベースの裏側にあるインターナルゾーン、それこそ仕組みというのを理解する、 基本を理解するというのは本当に大事なポイントかなと思うので、 この本をBookClubと並行して一緒に読んでくれているリスナーの方もいらっしゃると思うんですけども、 途中で挫折してもいいので、この章だけはぜひ、 B3知らないよという方はぜひ、この章だけでも頑張って読んでみると絶対生きてくると思うので、 一緒に頑張りましょうということで、 今回はChapter2 B3 Baby6の振り返りをソロ収録で収録しました。 皆さんありがとうございました。またChapter3でお会いしましょう。 ご視聴ありがとうございました。

## **English Summary**

## **Transcript**

In this episode, Katsuuma Kiba of London Tech Lab looks back on the second meeting of the Database Internals Book Club, which delved into the specifics of the B3 (B-tree). The episode focuses on the fundamental role and operation of B3s in databases, highlighting their importance in managing data efficiently. Ideas are shared for further exploring B3s through external resources, such as YouTube videos and web applications that were shared by participating members. Additionally, the episode touches on the mechanics of spinning disks and SSDs, clearly demonstrating the importance of optimizations within the DBMS and the B3 tree. For anyone interested in the fundamentals and optimizations of databases, this is a compelling episode that will provide further insight into the internal workings of databases, complemented by external resources that help solidify the understanding of B3s.


## **English Transcription**

## **Transcription**

♫ Welcome to London Tech Talk, London, to the listeners. I'm Katsuuma Keiba. Today, by myself, I will summarize the second Database Internals Book Club meeting. In this meeting, we will discuss Chapter 2, B-tree basics. When talking about database, B-tree comes up very often. Many of you may have heard about B-tree in a conversation about an index or in articles about database performance tuning. However, you may also wonder why B-tree is so often utilized in DBMS. For example, wouldn't a simple binary search tree be okay? A database management system (DBMS), which we explore in this book, is designed to store a large amount of data inexpensively and enable fast reads and updates. In the case of disk-based DBMS, data gets stored in disks. However, disks are not as fast as RAM, especially for random access, which is very slow. That's where locality, or locality of data, becomes crucial. We need a data structure to minimize the number of disk accesses, and that's where B-tree comes in. To be exact, it's a B+ tree. With its high fanout and low height, this structure minimizes the number of disk seeks, which allows for efficient search and update. Chapter 2 explains why B-tre is a common choice, especially in the world of disk-based DBMS. To understand why, the chapter delves into the basic operations and structure of the B-tree. For example, it shows how separator keys are used to efficiently navigate to the target data during searches. It also explains how keys are designed to enable range queries that fetch the necessary data efficiently. When adding or deleting data, B-tree must maintain its balanced state. To achieve this, it may split or merge nodes. The chapter's goal is to establish a mental model for the basic operations of B-tree. Let's now briefly recap the content of Chapter 2, B-Tree Basics, and discuss which topics generated the most discussion. This time, we had participants from EMEA and North America. The APAC team had to join us asynchronously due to the time difference. In the end, the APAC team had the most participants, but EMEA and North America had the smallest group of attendees. For the first meeting, APAC and EMEA participated in the club. It was a lively session with many participants. Since it was the first time, the excitement was evident, and we all felt a positive sense of anticipation as we embarked on this challenging journey. In contrast, we had only seven attendees for this meeting. Two people couldn't make it in the end, so it was just the five of us. Despite the small group size, it was a great experience. The discussion was more relaxed, and everyone had ample time to share their perspectives. It felt like a cozy seminar taking place in a university building as dusk fell on campus around 5 or 6 pm. The atmosphere was enjoyable yet focused, and it was fascinating to see how the ambiance could differ so significantly depending on the size of the group. I feel we were able to have a more in-depth discussion about B-trees this time. I stated in the intro that the key takeaway from Chapter 2 is to understand why B-trees are so popular. If you can grasp that, then you've successfully completed the chapter. A database management system primarily needs to store vast amounts of data inexpensively. Therefore, two keywords become crucial in understanding how to store data and achieve fast read-write operations on hard disks and SSDs. The first is high fanout. Since writes are random but we need to store the data together based on its affinity, maintaining data locality is essential. To reduce the number of reads and writes and therefore the number of disk accesses, we need to reduce the height of the tree structure. To illustrate, let's compare binary search trees (BST) and B-trees as storage methods. In a binary search tree, each node has a maximum of two child nodes. So, when storing a large dataset, the height of the tree can grow significantly. When DBMS stores data, it uses data blocks, or pages, which in turn correspond to nodes in the tree structure. If the tree has many levels and needs to be traversed multiple times, it means more reads from the disk. The slowest operation in DBMS is fetching pages from the disk. Therefore, fundamentally, we want to reduce the number of disk accesses. To do this, instead of having nodes with only two child nodes, like in a binary search tree, we can design nodes with multiple child nodes. This action reduces the height of the tree structure and results in a low height. It creates a data structure that minimizes the number of disk seeks. High fanout means having a large number of child nodes and increasing the fanout. Achieving high fanout and low height go hand in hand, allowing for disk friendliness, better disk locality, and a data layout that minimizes disk seeks. These concepts are explored throughout the chapter.。## **Transcription**

I think it would be good to understand two main aspects of B3's basic operations. The first one is the lookup. It's a search, a get, or in other words, reading out information. Try to visualize how, inside your head, the data is stored on B3, and when a query is received for this key, how do you traverse this key structure to reach the target node. I think it would be good to understand this while visualizing it. If you only read this book, it would be very hard to visualize such dynamic movements. This is something that one of the participants shared with me. There is a famous database-related lecture on YouTube from CMU, Carnegie Mellon University. One of the lectures there talks about B3 in detail. It has simple animations that visualize what happens when there's a node split, node rotation, or a lookup. It's represented in slides with animations. If you watch this, you can visually understand it. I think I will add a link to this in the show notes or on YouTube. When you look up B3, you can see how it traverses the tree structure, or how, when there's a node split or node rotation, it splits or rotates the nodes in the best possible way. I think that will help you understand it visually. Another thing is, this is also something that another participant shared with me, but there's a web app that's probably implemented entirely in JavaScript. You input what data to add in a text field, and as you keep adding data, it can show you the actual tree structure, B3, on the web browser. You can try this out with your own data, like entering integers in order, like 1, 2, 3, and see how the tree structure changes. Or, you can delete data and see how it splits. By testing this out, you can get a deeper understanding. I'll add the link I was given to the show notes. Basically, the first half of Part 1 is dedicated to getting a deep understanding of B3. Chapters 3 and 4 also continue the discussion assuming that you have understood these basic operations of B3 in Chapter 2. So, I think it's good to take your time here and understand it by also using external resources such as YouTube or the web app, depending on your learning style. The discussions were quite lively, so let me pick up a few things. First of all, in the first half of Chapter 2, there was an explanation about the disk。## **Transcription**

First of all, there are questions like how do hard disks, drives, and SSDs work at the block level, and what is disk seek? For example, some people who have just entered the computer world in recent years may have never used a hard disk. I entered the computer world when hard disk drives were mainstream, so my first computer used a hard disk. However, when you buy a recent Mac, it basically uses an SSD. So, some people may not know that a hard disk is a disk-type and that disk seek involves the needle and disk moving like this. Therefore, I think that beginners should definitely look up how a hard disk works on YouTube or somewhere else. Then, you will understand why DBMS needs to reduce disk seek count. Disk seek is a time-consuming operation, especially for hard disk drives. Therefore, this is basically the bottleneck. So, before reading this chapter, the premise knowledge and mindset is to first understand how to reduce disk seek on hard disks. I don't think people can understand why database engineers try so hard to optimize B-Trees without having this negative feeling. So, please keep in mind that if you can slightly understand it on a hard disk drive and even on an SSD, you will understand the author's feelings. Then, regarding B-Tree, the original B-Tree was announced around 1970, and various ashes or variants have been announced since then. There are many variations on B-Tree, such as Blink Tree and B+ Tree. For example, write-optimized balanced B-Tree is for improving write performance, and there are B-Trees that have been slightly changed so that the movement of nodes of the same level can be moved more easily using sibling pointers. The point that I want to emphasize here is that when talking about B-Tree in the world of DBMS like MyISAM or Postgres, it is important to understand whether they are talking about B-Tree in a competitive sense or in a derogatory sense. The competitive B-Tree is the one that was announced in the 1970 paper, but I don't think that is often referred to as B-Tree online or in documentation. Unless it is in the academic world or referring to a specific paper.。## **Transcript**

Basically, B3 is often used as B-plus 3. The difference between B3 and B-plus 3 is the difference in where the data block, child node, and pointer to the old node are stored. To put it simply, the original B3 was an intermediate node. So when considering the tree structure, the intermediate nodes were between the top-most root node and the lowest leaf node. The original B3 was devised on the premise that data is stored in the intermediate nodes. However, in 1973, it was proposed that storing data only in the leaf nodes would improve performance. That was B-plus 3. So basically, it's good to understand that B-plus 3 is what is generally discussed in the DBMS world. First, you need to understand why B3 is so optimized in terms of the behavior of hard disk SSDs. Then, you need to understand that there are various hash functions for B3, such as B-plus 3. And I think the goal of reading this chapter has been achieved by understanding the basic operations of B3. Based on the basics here, you can investigate which indexes, data structures, and hash functions of B3 your database management system supports. You can also investigate the behavior of hard disks and SSDs in more detail. From here on, there are various directions to explore in more depth, depending on your personal preferences and interests. I think it was different. Personally, I read this chapter to refresh the contents of a data structure book that I had read before, as the basics of B3. As I mentioned in the introduction, this is an important chapter, because later in the book, other data structures are introduced, such as LSM trees, log-structured merge trees, and LM series databases, which are used in recent real applications, such as OxDB developed by Meta. To understand LSM trees and SS tables used there, it is important to understand that before LSM trees and SS tables, the world of database technology revolved around B-trees. This understanding will allow you to proceed to other advanced data structures and their flow. Finally, one interesting thing is that I investigated something in detail while reading this chapter. For example, there is MySQL.。## **Transcription**

There are disk-based DBMSs that are basically disk-based. There are many companies in the world that use MySQL and try to optimize it in various ways. If you use the default settings, the storage engine implementation called InnoDB is probably used, and you'll probably end up using the B-tree index-based implementation. If you understand the basics of B-trees, you'll know that while write performance can improve up to a certain scale, when it reaches a larger scale such as Facebook or other large global enterprises or even YouTube, there will be a bottleneck somewhere. There are various methods to improve performance in such cases and increase revenue by achieving horizontal scaling, but one of the interesting examples is MyRocks, which was released around 2006 or 2007 and some of you may know about it. Facebook has an implementation called MyRocks, which essentially replaces the default InnoDB storage engine with a completely different key-value store called RocksDB. RocksDB is an open-source list written in C++ that was also released by Facebook. Some of you may have seen the logo which has an animal that looks like a cougar or a leopard running. It's a key-value store based on a log-structured merge tree (LSM) called SSTable implementation. There was a case where they wanted to significantly improve performance, so instead of continuing to use the B-tree index-based InnoDB, they replaced the implementation at the index level with something completely different. They announced MyRocks, which is suitable for specific use cases. There have been cases like this. That's why I also found MyRocks to be interesting, but understanding why there are people who need to scale applications to Facebook's level, how the default InnoDB couldn't handle it, what B-trees are used for behind the scenes, how they operate, what their structure is, and in what situations they hit performance bottlenecks will help you realize that it was necessary to replace it with an LSM-based approach like MyRocksDB or LocksDB. This is why I believe it's really important to understand the internal mechanisms or the basics of databases when trying to understand online articles about databases or initiatives by other companies. I think there are listeners who are reading this book along with BookClub, so even if you feel discouraged at some point, please try to at least finish this chapter. If you don't know about B-trees, I encourage you to read this chapter because it will definitely be beneficial. Let's work together and I'll finish Chapter 2: B-tree Basics by myself. Thank you everyone. I'll see you in Chapter 3.。## **Transcript**

Thank you for watching.

